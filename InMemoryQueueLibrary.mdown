# In Memory Highly Concurrent Queue Library

## Problem Statement

Implement an in memory, highly concurrent queue service with the following interface:

    // Creates a queue with the given name (if the name is unique) and returns a
    // QueueId
    QueueId createQueue(QueueName)
    QueueId getQueue(QueueName)
    // Deletes the given queue
    void deleteQueue(QueueId)

    // Enqueue the object into the queue with the given id.
    void enqueue(QueueId, Object)

    // Read an object from the queue.
    // This object will not be returned as a response to
    // another read until the given timeout has expired.
    // Once dequeue is called then the object will not be
    // returned by a subsequent read.
    ReadResponse read(QueueId, timeout)

    // Dequeue the object with the given QueueEntityId
    // A dequeue permanently removes the object from the queue.
    void dequeue(QueueId, QueueEntityId)

    Datatypes:
    QueueId: String. Opaque to the user
    QueueEntityId: String. Opaque to the user.
    Object: byte[] - Max size 1K

    ReadResponse {
        QueueId
        QueueEntityId
        Object
    }

The queue service is exposing a queue abstraction that multiple consumers can read from concurrently. A notion of read timeouts is also introduced to deal with a consumer failing and not successfully handling a message. Thus, the queue exposed has at least once delivery semantics.


## Deliverables

1. Source code for this service that one could use as a library.
1. Please also include tests that exercise the APIs and test whatever you think is relevant.
1. If there were any interesting tradeoffs or assumptions you had to make, please explain them in a short write up.

## Important notes

* FIFO and concurrency:
  The definition of a FIFO queue in the presence of concurrent consumers and producers becomes a little hazy. The only way to implement a strictly FIFO queue would be to not allow a second read call, until the previous read had been dequeued. That would obviously kill any concurrency and we don't want to do that.
  However, we also don't want to pull items out at random from the queue. What we'd like is a concurrent queue that is FIFOish. Please define or explain how you balance these concerns. Nothing very formal, just an explanation of your design decisions.
* Feel free to add to or modify the above interface as you see fit. Just include your reasoning for any changes you make.
* You should be able to support high concurrency, both within a queue and across multiple queues. Feel free to make any design decisions about how to balance those concerns. Just document your rationale.
* The queue only needs to be in memory. Do not worry about persistence.
* Feel free to use whatever language / framework you are most comfortable with.
